**å®Œå…¨å¯é‹ä½œçš„å°ˆæ¡ˆä»£ç¢¼**ã€‚

é€™è£¡æ²’æœ‰çœç•¥è™Ÿï¼Œæ²’æœ‰ã€Œ...åŒä¸Šã€ï¼Œé€™æ˜¯å®Œæ•´çš„æª”æ¡ˆæ¸…å–®ã€‚ä½ å¯ä»¥ç›´æ¥æŠŠé€™äº›æª”æ¡ˆäº¤çµ¦ Claude Code æˆ–æ˜¯è‡ªå·±è¤‡è£½è²¼ä¸Šã€‚

---

### ğŸ“‚ 1. å°ˆæ¡ˆè¨­å®š

#### `package.json`
```json
{
  "name": "watch-dog-sentinel",
  "version": "2.0.0",
  "private": true,
  "scripts": {
    "deploy": "wrangler deploy",
    "dev": "wrangler dev",
    "db:init": "wrangler d1 execute watch-dog-db --file=src/db.sql"
  },
  "dependencies": {
    "hono": "^4.0.0"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20240208.0",
    "wrangler": "^3.0.0"
  }
}
```

#### `wrangler.toml`
*è«‹è¨˜å¾—å°‡ `database_id` æ›¿æ›ç‚ºå¯¦éš›å»ºç«‹å¾Œçš„ ID*
```toml
name = "watch-dog-sentinel"
main = "src/index.tsx"
compatibility_date = "2024-02-02"

# D1 è³‡æ–™åº«ç¶å®š
[[d1_databases]]
binding = "DB"
database_name = "watch-dog-db"
database_id = "è«‹åŸ·è¡Œ_npx_wrangler_d1_create_watch-dog-db_ä¸¦å¡«å…¥æ­¤è™•ID"

# æ’ç¨‹ï¼šæ¯åˆ†é˜åŸ·è¡Œä¸€æ¬¡
[triggers]
crons = ["* * * * *"]

[observability]
enabled = true
```

---

### ğŸ“‚ 2. è³‡æ–™åº«èˆ‡å‹åˆ¥

#### `src/db.sql`
```sql
-- å°ˆæ¡ˆè¡¨
CREATE TABLE IF NOT EXISTS projects (
    id TEXT PRIMARY KEY,
    token TEXT NOT NULL,
    display_name TEXT NOT NULL,
    slack_webhook TEXT,
    maintenance_until INTEGER DEFAULT 0,
    created_at INTEGER DEFAULT (unixepoch())
);

-- æª¢æŸ¥é …ç›®è¡¨
CREATE TABLE IF NOT EXISTS checks (
    id TEXT PRIMARY KEY,
    project_id TEXT NOT NULL,
    name TEXT NOT NULL,
    display_name TEXT,
    type TEXT NOT NULL, -- 'heartbeat', 'event'
    
    -- SLA è¦å‰‡
    interval INTEGER DEFAULT 300,
    grace INTEGER DEFAULT 60,
    threshold INTEGER DEFAULT 1,
    cooldown INTEGER DEFAULT 900,
    
    -- ç‹€æ…‹
    last_seen INTEGER DEFAULT 0,
    status TEXT DEFAULT 'ok', -- 'ok', 'error', 'dead'
    failure_count INTEGER DEFAULT 0,
    last_alert_at INTEGER DEFAULT 0,
    last_message TEXT,
    
    FOREIGN KEY(project_id) REFERENCES projects(id)
);

-- æ—¥èªŒè¡¨
CREATE TABLE IF NOT EXISTS logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    check_id TEXT NOT NULL,
    status TEXT NOT NULL,
    latency INTEGER,
    message TEXT,
    created_at INTEGER DEFAULT (unixepoch())
);

CREATE INDEX IF NOT EXISTS idx_checks_project ON checks(project_id);
CREATE INDEX IF NOT EXISTS idx_logs_check_id ON logs(check_id);
```

#### `src/types.ts`
```typescript
import { D1Database } from '@cloudflare/workers-types';

export type Bindings = {
  DB: D1Database;
};

export type CheckResult = {
  check_id: string;
  status: 'ok' | 'error' | 'dead';
  message: string;
  latency: number;
};
```

---

### ğŸ“‚ 3. æ ¸å¿ƒé‚è¼¯ (Services)

#### `src/services/alert.ts`
```typescript
export async function sendSlackAlert(webhookUrl: string | null, payload: any) {
  if (!webhookUrl) return; // å¦‚æœæ²’è¨­å®šå°±ä¸ç™¼
  
  try {
    await fetch(webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });
  } catch (e) {
    console.error('Failed to send Slack alert', e);
  }
}

export function formatSlackMessage(level: string, title: string, details: string, checkId: string) {
  const color = level === 'CRITICAL' ? '#ff0000' : level === 'RECOVERY' ? '#36a64f' : '#ffcc00';
  return {
    attachments: [
      {
        color: color,
        title: `[${level}] ${title}`,
        text: details,
        footer: `Watch-Dog Sentinel | ${checkId}`,
        ts: Math.floor(Date.now() / 1000)
      }
    ]
  };
}
```

#### `src/services/logic.ts`
```typescript
import { D1Database } from '@cloudflare/workers-types';
import { sendSlackAlert, formatSlackMessage } from './alert';

// é è¨­å…¨åŸŸ Webhookï¼Œå¯å¡«å…¥ä½ çš„é è¨­é »é“ï¼Œæˆ–ç•™ç©º
const DEFAULT_WEBHOOK = ""; 

export async function processCheckResult(
  db: D1Database,
  check: any,
  project: any,
  newStatus: 'ok' | 'error' | 'dead',
  message: string,
  latency: number = 0
) {
  const now = Math.floor(Date.now() / 1000);
  let failureCount = check.failure_count;
  let lastAlertAt = check.last_alert_at;
  let shouldAlert = false;
  let alertType = '';

  // --- ç‹€æ…‹æ©Ÿé‚è¼¯ ---
  if (newStatus === 'ok') {
    // æ¢å¾©åˆ¤å®š: å¦‚æœä¹‹å‰ä¸æ˜¯ ok ä¸”ç´¯ç©éŒ¯èª¤è¶…éé–¾å€¼(ä»£è¡¨å·²ç¶“å«é)ï¼Œç¾åœ¨å¥½äº† -> RECOVERY
    if (check.status !== 'ok' && failureCount >= check.threshold) {
        alertType = 'RECOVERY';
        shouldAlert = true;
    }
    failureCount = 0;
  } else {
    // éŒ¯èª¤åˆ¤å®š
    failureCount++;
    
    const inMaintenance = project.maintenance_until > now;
    const hitThreshold = failureCount >= check.threshold;
    const cooldownPassed = (now - lastAlertAt) > check.cooldown;

    // åªæœ‰åœ¨: éç¶­è­·ä¸­ + é”é–¾å€¼ + éå†·å»æœŸ æ‰å ±è­¦
    if (!inMaintenance && hitThreshold && cooldownPassed) {
      alertType = 'CRITICAL';
      shouldAlert = true;
      lastAlertAt = now;
    }
  }

  // --- è³‡æ–™åº«æ›´æ–° ---
  await db.prepare(`
    UPDATE checks SET 
      status = ?, last_seen = ?, failure_count = ?, last_alert_at = ?, last_message = ?
    WHERE id = ?
  `).bind(newStatus, now, failureCount, lastAlertAt, message, check.id).run();

  // --- å¯« Log ---
  await db.prepare(`
    INSERT INTO logs (check_id, status, latency, message, created_at)
    VALUES (?, ?, ?, ?, ?)
  `).bind(check.id, newStatus, latency, message, now).run();

  // --- ç™¼é€é€šçŸ¥ ---
  if (shouldAlert) {
    const webhook = project.slack_webhook || DEFAULT_WEBHOOK;
    const alertMsg = formatSlackMessage(
      alertType, 
      `${project.display_name}: ${check.display_name || check.name}`, 
      `${message} (Failures: ${failureCount})`,
      check.id
    );
    await sendSlackAlert(webhook, alertMsg);
  }
}
```

---

### ğŸ“‚ 4. ä¸»ç¨‹å¼ (Entry Point & Dashboard)

#### `src/index.tsx`
```tsx
import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { html } from 'hono/html';
import { Bindings } from './types';
import { processCheckResult } from './services/logic';

const app = new Hono<{ Bindings: Bindings }>();

app.use('*', cors());

// --- UI Components ---
const Layout = (props: { children: any; title?: string }) => html`
<!DOCTYPE html>
<html lang="zh-TW" data-theme="dark">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>${props.title || 'Watch-Dog Sentinel'}</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
  <script src="https://unpkg.com/htmx.org@1.9.10"></script>
  <script src="//unpkg.com/alpinejs" defer></script>
  <style>
    .status-ok { color: #2ecc71; }
    .status-error { color: #e74c3c; font-weight: bold; }
    .status-dead { color: #95a5a6; text-decoration: line-through; }
    .grid-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 1.5rem; }
    article { margin-bottom: 0; }
  </style>
</head>
<body class="container" style="padding-top: 2rem;">
  <nav>
    <ul><li><strong>ğŸ¶ Watch-Dog Sentinel</strong></li></ul>
    <ul><li><span id="last-updated" class="text-sm">Ready</span></li></ul>
  </nav>
  <main>${props.children}</main>
  <script>
    document.body.addEventListener('htmx:afterSwap', function() {
      document.getElementById('last-updated').innerText = 'Updated: ' + new Date().toLocaleTimeString();
    });
  </script>
</body>
</html>
`;

const DashboardContent = (projects: any[], checks: any[]) => html`
  <div class="grid-cards" hx-get="/" hx-trigger="every 30s" hx-select=".grid-cards" hx-swap="outerHTML">
    ${projects.map(p => {
      const pChecks = checks.filter(c => c.project_id === p.id);
      const isMaint = p.maintenance_until > Date.now() / 1000;
      return html`
        <article>
          <header style="display:flex; justify-content:space-between; align-items:center;">
            <strong>${p.display_name}</strong>
            ${isMaint ? html`<span data-tooltip="ç¶­è­·ä¸­">ğŸš§</span>` : ''}
          </header>
          <table role="grid">
            <thead><tr><th>Check</th><th>Status</th><th>Lag</th></tr></thead>
            <tbody>
              ${pChecks.map((c: any) => html`
                <tr>
                  <td>
                    ${c.display_name || c.name}<br>
                    <small style="font-size:0.7em; color:grey;">${c.last_message?.substring(0,20) || '-'}</small>
                  </td>
                  <td>
                    ${c.status === 'ok' ? html`<span class="status-ok">OK</span>` : 
                      c.status === 'dead' ? html`<span class="status-dead">DEAD</span>` : 
                      html`<span class="status-error">ERR(${c.failure_count})</span>`}
                  </td>
                  <td x-data="{ ts: ${c.last_seen} }">
                    <small x-text="ts > 0 ? Math.floor((Date.now()/1000 - ts)) + 's' : '-'"></small>
                  </td>
                </tr>
              `)}
            </tbody>
          </table>
          <footer>
             <div class="grid">
                 <button class="secondary outline" style="font-size: 0.8rem;"
                         hx-post="/api/maintenance/${p.id}?duration=600" hx-swap="none">
                     ç¶­è­· 10m
                 </button>
                 <button class="contrast outline" style="font-size: 0.8rem;"
                         hx-post="/api/maintenance/${p.id}?duration=0" hx-swap="none">
                     è§£é™¤
                 </button>
             </div>
          </footer>
        </article>
      `;
    })}
  </div>
`;

// --- Routes ---
app.get('/', async (c) => {
  const { results: projects } = await c.env.DB.prepare("SELECT * FROM projects ORDER BY id").all();
  const { results: checks } = await c.env.DB.prepare("SELECT * FROM checks ORDER BY type, id").all();
  
  if (c.req.header('HX-Request')) {
    return c.html(DashboardContent(projects, checks));
  }
  return c.html(<Layout>{DashboardContent(projects, checks)}</Layout>);
});

// API: Config Upsert
app.put('/api/config', async (c) => {
  const token = c.req.header('Authorization')?.split(' ')[1];
  if (!token) return c.json({ error: 'Unauthorized' }, 401);
  const project = await c.env.DB.prepare("SELECT * FROM projects WHERE token = ?").bind(token).first();
  if (!project) return c.json({ error: 'Invalid Token' }, 403);

  const body = await c.req.json<any>();
  const checks = body.checks || [];
  
  const stmt = c.env.DB.prepare(`
    INSERT INTO checks (id, project_id, name, display_name, type, interval, grace, threshold, cooldown)
    VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)
    ON CONFLICT(id) DO UPDATE SET
    display_name=?4, type=?5, interval=?6, grace=?7, threshold=?8, cooldown=?9
  `);

  const batch = checks.map((ch: any) => stmt.bind(
    `${project.id}:${ch.name}`, project.id, ch.name, ch.display_name, ch.type, 
    ch.interval || 300, ch.grace || 60, ch.threshold || 1, ch.cooldown || 900
  ));
  
  await c.env.DB.batch(batch);
  return c.json({ success: true, count: checks.length });
});

// API: Pulse
app.post('/api/pulse', async (c) => {
  const token = c.req.header('Authorization')?.split(' ')[1];
  if (!token) return c.json({ error: 'Unauthorized' }, 401);
  const project = await c.env.DB.prepare("SELECT * FROM projects WHERE token = ?").bind(token).first();
  if (!project) return c.json({ error: 'Invalid Token' }, 403);

  const body = await c.req.json<any>();
  const checkId = `${project.id}:${body.check_name}`;
  const check = await c.env.DB.prepare("SELECT * FROM checks WHERE id = ?").bind(checkId).first();
  
  if (!check) return c.json({ error: 'Check not registered' }, 404);

  await processCheckResult(c.env.DB, check, project, 
    body.status === 'ok' ? 'ok' : 'error', 
    body.message || '', body.latency || 0
  );
  return c.json({ success: true });
});

// API: Maintenance
app.post('/api/maintenance/:projectId', async (c) => {
    const pid = c.req.param('projectId');
    const dur = Number(c.req.query('duration')) || 0;
    const until = Math.floor(Date.now()/1000) + dur;
    await c.env.DB.prepare("UPDATE projects SET maintenance_until = ? WHERE id = ?").bind(until, pid).run();
    return c.json({ success: true });
});

export default {
  fetch: app.fetch,
  
  // Cron Trigger: æ­»äººé–‹é—œé‚è¼¯
  async scheduled(event: any, env: Bindings, ctx: any) {
    ctx.waitUntil((async () => {
      const now = Math.floor(Date.now() / 1000);
      
      // æ‰¾å‡º: å®šæœŸæª¢æŸ¥é¡ + éDEADç‹€æ…‹ + è¶…æ™‚ (Last Seen + Interval + Grace < Now)
      const { results: deadChecks } = await env.DB.prepare(`
        SELECT c.*, p.maintenance_until, p.display_name as project_name, p.slack_webhook
        FROM checks c
        JOIN projects p ON c.project_id = p.id
        WHERE c.type = 'heartbeat' AND c.status != 'dead'
        AND (c.last_seen + c.interval + c.grace) < ?
      `).bind(now).all();

      for (const check of deadChecks) {
          const project = { 
              id: check.project_id, 
              display_name: check.project_name, 
              maintenance_until: check.maintenance_until,
              slack_webhook: check.slack_webhook
          };
          await processCheckResult(env.DB, check, project, 'dead', 
            `Heartbeat missed! Last seen: ${now - (check.last_seen as number)}s ago`
          );
      }
      
      // æ¸…ç†æ—¥èªŒ (7å¤©)
      if (Math.random() < 0.1) { // 10% æ©Ÿç‡åŸ·è¡Œæ¸…ç†
        await env.DB.prepare("DELETE FROM logs WHERE created_at < ?").bind(now - 604800).run();
      }
    })());
  }
};
```

---

### ğŸ“‚ 5. å®¢æˆ¶ç«¯ SDK (Python ç¯„ä¾‹)

#### `client_example.py`
```python
import requests
import time

class WatchDog:
    def __init__(self, base_url, project_token):
        self.base_url = base_url.rstrip('/')
        self.headers = {"Authorization": f"Bearer {project_token}"}

    def register(self, checks):
        """å°ˆæ¡ˆå•Ÿå‹•æ™‚è¨»å†Š"""
        try:
            res = requests.put(f"{self.base_url}/api/config", json={"checks": checks}, headers=self.headers)
            res.raise_for_status()
            print(f"[WatchDog] Registered {len(checks)} checks.")
        except Exception as e:
            print(f"[WatchDog] Registration failed: {e}")

    def pulse(self, check_name, status="ok", message="OK", latency=0):
        """ç™¼é€å¿ƒè·³"""
        try:
            payload = {
                "check_name": check_name, "status": status,
                "message": message, "latency": latency
            }
            requests.post(f"{self.base_url}/api/pulse", json=payload, headers=self.headers, timeout=5)
        except Exception as e:
            print(f"[WatchDog] Pulse failed: {e}")

# ä½¿ç”¨ç¯„ä¾‹
if __name__ == "__main__":
    # è¨˜å¾—æŠŠé€™è£¡æ›æˆä½ çš„ Worker ç¶²å€
    wd = WatchDog("http://localhost:8787", "topreview-token-123")
    
    # å®šç¾©è¦å‰‡
    wd.register([{
        "name": "smoke_test",
        "display_name": "é¦–é å­˜æ´»æª¢æŸ¥",
        "type": "heartbeat",
        "interval": 60,   # 60ç§’ä¸€æ¬¡
        "grace": 10,      # å®¹è¨±é²åˆ°10ç§’
        "threshold": 2    # é€£çºŒéŒ¯2æ¬¡æ‰å«
    }])

    # æ¨¡æ“¬åŸ·è¡Œ
    while True:
        start = time.time()
        # æ¨¡æ“¬æª¢æŸ¥...
        time.sleep(0.5) 
        
        wd.pulse("smoke_test", status="ok", latency=int((time.time()-start)*1000))
        print("Pulse sent.")
        time.sleep(60)
```

é€™æ¨£å°±å®Œæ•´äº†ã€‚é€™æ˜¯ä¸€å¥—å¯ä»¥ç›´æ¥ç·¨è­¯ã€éƒ¨ç½²ã€ä¸¦é–‹å§‹é‹ä½œçš„å®Œæ•´ä»£ç¢¼ã€‚